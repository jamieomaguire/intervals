<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas-based Timer with Intervals</title>
</head>

<body>
  <!-- Input fields for countdown and rounds -->
  <fieldset>
    <label for="countdown">Countdown before start (seconds):</label>
    <input type="number" name="countdown" id="countdown" value="0">
  </fieldset>
  <fieldset>
    <label for="rounds">Rounds:</label>
    <input type="number" name="rounds" id="rounds" value="1">
  </fieldset>

  <!-- Container to hold interval input fields -->
  <div id="intervalContainer">
    <fieldset class="intervalFieldset">
      <label>Interval 1: </label>
      <input type="text" placeholder="Interval Name" class="interval-name">
      <input type="number" placeholder="Duration (seconds)" class="interval-duration">
      <input type="color" class="interval-color">
    </fieldset>
  </div>

  <!-- Buttons to add intervals and control the timer -->
  <button id="addInterval">Add Interval</button>
  <canvas id="timerCanvas"></canvas>
  <button id="startTimer">Start</button>
  <button id="stopTimer">Stop</button>

  <hr>
  <button id="saveToQR">Save</button>
  <button id="scanQR">Scan QR</button>
  <div id="qrCode"></div>
  <video id="preview"></video>
  <div id="qroutput"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
  <script type="module">
    import QrScanner from './qr-scanner.min.js';

    /** Global variables */
    let startTime;
    let elapsed;
    let timerStopped = true;
    let intervals = [];
    let currentIntervalIndex = 0;
    let rounds;
    let currentRound = 1;
    let countdownDuration = 0;
    let inCountdown = false;

    const canvas = document.getElementById('timerCanvas');
    canvas.style.border = '1px dashed purple';
    const ctx = canvas.getContext('2d');

    /** Initial canvas setup */
    window.devicePixelRatio = 2;
    const size = 250;

    canvas.style.width = size + "px";
    canvas.style.height = size + "px";

    const scale = window.devicePixelRatio;
    canvas.width = size * scale;
    canvas.height = size * scale;

    ctx.scale(scale, scale);
    ctx.font = '30px Arial';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'left';

    const x = size / 2;
    const y = size / 2;

    // Event Listeners
    document.getElementById('addInterval').addEventListener('click', addInterval);
    document.getElementById('startTimer').addEventListener('click', startTimer);
    document.getElementById('stopTimer').addEventListener('click', stopTimer);
    document.getElementById('saveToQR').addEventListener('click', saveToQR);
    document.getElementById('scanQR').addEventListener('click', scanQR);


    /**
     * Draws the given time on the canvas
     * @param {number} time - Time in milliseconds
     * @param {string} [intervalName=''] - Name of the current interval
     * @param {boolean} [displayRound=true] - Flag to display the current round
     */
    function drawTime(time, intervalName = '', displayRound = true) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const minutes = Math.floor(time / 60000);
      const seconds = Math.floor((time % 60000) / 1000);
      const milliseconds = time % 1000;

      const minutesText = `${minutes}:`;
      const secondsText = `${seconds.toString().padStart(2, '0')}.`;
      const milliText = milliseconds.toString().slice(0, 2);

      const minutesMetrics = ctx.measureText(minutesText);
      const secondsMetrics = ctx.measureText(secondsText);

      ctx.fillText(minutesText, x - minutesMetrics.width - secondsMetrics.width, y - 30);
      ctx.fillText(secondsText, x - secondsMetrics.width, y - 30);
      ctx.fillText(milliText, x, y - 30);

      if (displayRound) {
        ctx.fillText(`${currentRound}/${rounds}`, x - (ctx.measureText(`On ${currentRound}/${rounds}`).width / 2), y);
      }

      ctx.fillText(intervalName, x - (ctx.measureText(intervalName).width / 2), y + 30);
    }

    /** 
     * Animation function to handle timer countdown and transitions
     * @param {number} currentTime - Current timestamp provided by requestAnimationFrame 
     */
    function animate(currentTime) {
      if (!startTime) {
        startTime = currentTime;
      }

      elapsed = currentTime - startTime;

      if (inCountdown) {
        let remainingTime = countdownDuration - elapsed;
        if (remainingTime <= 0) {
          inCountdown = false;
          document.body.style.backgroundColor = intervals[0].color;
          startTime = null;
          animate(currentTime);
          return;
        }
        drawTime(remainingTime, 'Countdown', false);
      } else {
        let currentInterval = intervals[currentIntervalIndex];
        let remainingTime = currentInterval.duration - elapsed;

        if (remainingTime <= 0) {
          currentIntervalIndex++;

          if (currentIntervalIndex >= intervals.length) {
            currentRound++;
            currentIntervalIndex = 0;
          }

          if (currentRound > rounds) {
            timerStopped = true;
            currentIntervalIndex = intervals.length - 1;
            document.body.style.backgroundColor = 'white';
            currentRound = rounds; // Correcting the round display
            drawTime(0);
            return;
          }

          currentInterval = intervals[currentIntervalIndex];
          document.body.style.backgroundColor = currentInterval.color;
          startTime = null;
          elapsed = 0;
          remainingTime = currentInterval.duration;
        }

        drawTime(remainingTime, currentInterval.name);
      }

      if (!timerStopped) {
        requestAnimationFrame(animate);
      } else {
        console.log('timer stopped');
      }
    }

    /** 
     * Starts the timer after capturing user inputs 
     */
    function startTimer() {
      captureInputs();
      if (timerStopped && intervals.length > 0) {
        timerStopped = false;
        currentIntervalIndex = 0;
        currentRound = 1;
        if (countdownDuration > 0) {
          inCountdown = true;
        } else {
          document.body.style.backgroundColor = intervals[0].color;
        }
        startTime = null;
        requestAnimationFrame(animate);
      }
    }

    /** 
     * Stops the timer and resets some global states
     */
    function stopTimer() {
      timerStopped = true;
      currentIntervalIndex = 0;
      inCountdown = false;
      document.body.style.backgroundColor = 'white';
    }

    /** 
     * Captures inputs for intervals, countdown, and rounds
     */
    function captureInputs() {
      const intervalEls = document.querySelectorAll('.intervalFieldset');
      intervals = [];

      intervalEls.forEach(intervalEl => {
        const name = intervalEl.querySelector('.interval-name').value;
        const duration = parseInt(intervalEl.querySelector('.interval-duration').value) * 1000;
        const color = intervalEl.querySelector('.interval-color').value;

        if (name && duration) {
          intervals.push({ name, duration, color });
        }
      });

      countdownDuration = parseInt(document.getElementById('countdown').value) * 1000;
      rounds = parseInt(document.getElementById('rounds').value) || 1;
    }

    /** 
     * Adds another interval input field to the DOM 
     */
    function addInterval() {
      const container = document.getElementById('intervalContainer');
      const newInterval = document.createElement('fieldset');
      newInterval.className = 'intervalFieldset';
      newInterval.innerHTML = `
                <label>Interval ${container.querySelectorAll('.intervalFieldset').length + 1}: </label>
                <input type="text" placeholder="Interval Name" class="interval-name">
                <input type="number" placeholder="Duration (seconds)" class="interval-duration">
                <input type="color" class="interval-color">
            `;
      container.appendChild(newInterval);
    }

    // EXPERIMENTAL - QR CODE FUNCTIONALITY
    function saveToQR() {
      captureInputs();
      const settings = {
        intervals: intervals,
        rounds: rounds,
        countdownDuration: countdownDuration
      };

      const serialized = getCompressedConfigURL(settings);
      console.log(serialized)

      // Generate QR code using qrcodejs library
      const qrCodeEl = document.getElementById('qrCode');
      new QRCode(qrCodeEl, serialized);
    }

    function scanQR() {
      const videoElement = document.getElementById('preview');
      const qrScanner = new QrScanner(
        videoElement,
        result => {
          console.log(result)
          const data = JSON.parse(result.data);
          console.log(data);
          intervals = data.intervals;
          rounds = data.rounds;
          countdownDuration = data.countdownDuration;
          loadFromSettings();
        },
        { returnDetailedScanResult: true },
      );

      qrScanner.start();
    }

    function loadFromSettings() {
      // Populate the fields on the page based on the scanned settings
      document.getElementById('countdown').value = countdownDuration / 1000;
      document.getElementById('rounds').value = rounds;

      const container = document.getElementById('intervalContainer');
      container.innerHTML = '';

      intervals.forEach(interval => {
        const container = document.getElementById('intervalContainer');
        const newInterval = document.createElement('fieldset');
        newInterval.className = 'intervalFieldset';
        newInterval.innerHTML = `
                  <label>Interval ${container.querySelectorAll('.intervalFieldset').length + 1}: </label>
                  <input type="text" placeholder="Interval Name" class="interval-name" value="${interval.name}">
                  <input type="number" placeholder="Duration (seconds)" class="interval-duration" value="${interval.duration / 1000}">
                  <input type="color" class="interval-color" value="${interval.color}">
              `;

        container.appendChild(newInterval);
      });
    }


    // Function to compress the configuration and return a URL
    function getCompressedConfigURL(config) {
      const compressedConfig = LZString.compressToEncodedURIComponent(JSON.stringify(config));
      return `${window.location.origin}${window.location.pathname}?config=${compressedConfig}`;
    }

    // Function to decompress the configuration from the URL
    function decompressConfigFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const compressedConfig = urlParams.get('config');

      if (compressedConfig) {
        const decompressedConfig = LZString.decompressFromEncodedURIComponent(compressedConfig);
        return JSON.parse(decompressedConfig);
      }
      return null;
    }

    // Function to load configuration data into the input fields
    function loadConfigurationFromData(data) {
      document.getElementById('countdown').value = data.countdownDuration / 1000;
      document.getElementById('rounds').value = data.rounds;

      const intervalContainer = document.getElementById('intervalContainer');
      const existingIntervals = intervalContainer.querySelectorAll('.intervalFieldset');

      data.intervals.forEach((interval, index) => {
        let intervalFieldset;
        if (index < existingIntervals.length) {
          intervalFieldset = existingIntervals[index];
        } else {
          // Create a new interval fieldset if needed
          intervalFieldset = document.createElement('fieldset');
          intervalFieldset.className = 'intervalFieldset';
          intervalFieldset.innerHTML = `
                <label>Interval ${index + 1}: </label>
                <input type="text" placeholder="Interval Name" class="interval-name">
                <input type="number" placeholder="Duration (seconds)" class="interval-duration">
                <input type="color" class="interval-color">
            `;
          intervalContainer.appendChild(intervalFieldset);
        }

        // Set the values from the configuration data
        intervalFieldset.querySelector('.interval-name').value = interval.name;
        intervalFieldset.querySelector('.interval-duration').value = interval.duration / 1000;
        intervalFieldset.querySelector('.interval-color').value = interval.color;
      });

      // Remove any extra interval fieldsets
      while (intervalContainer.children.length > data.intervals.length) {
        intervalContainer.removeChild(intervalContainer.lastChild);
      }
    }

    // Load the configuration if present in the URL when the page loads
    document.addEventListener('DOMContentLoaded', (event) => {
      const config = decompressConfigFromURL();
      if (config) {
        loadConfigurationFromData(config);
      }
    });

  </script>
</body>

</html>